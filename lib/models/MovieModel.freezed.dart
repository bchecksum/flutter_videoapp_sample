// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'MovieModel.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;
MovieModel _$MovieModelFromJson(Map<String, dynamic> json) {
  return _MovieModel.fromJson(json);
}

/// @nodoc
class _$MovieModelTearOff {
  const _$MovieModelTearOff();

// ignore: unused_element
  _MovieModel call(
      {String title,
      String year,
      String rated,
      String released,
      String runtime,
      String genre,
      String director,
      String writer,
      String actors,
      String plot,
      String language,
      String country,
      String awards,
      String poster,
      List<RatingsModel> ratings,
      String metascore,
      String imdbRating,
      String imdbVotes,
      String imdbID,
      String type,
      String totalSeasons,
      String response,
      String videoID}) {
    return _MovieModel(
      title: title,
      year: year,
      rated: rated,
      released: released,
      runtime: runtime,
      genre: genre,
      director: director,
      writer: writer,
      actors: actors,
      plot: plot,
      language: language,
      country: country,
      awards: awards,
      poster: poster,
      ratings: ratings,
      metascore: metascore,
      imdbRating: imdbRating,
      imdbVotes: imdbVotes,
      imdbID: imdbID,
      type: type,
      totalSeasons: totalSeasons,
      response: response,
      videoID: videoID,
    );
  }

// ignore: unused_element
  MovieModel fromJson(Map<String, Object> json) {
    return MovieModel.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $MovieModel = _$MovieModelTearOff();

/// @nodoc
mixin _$MovieModel {
  String get title;
  String get year;
  String get rated;
  String get released;
  String get runtime;
  String get genre;
  String get director;
  String get writer;
  String get actors;
  String get plot;
  String get language;
  String get country;
  String get awards;
  String get poster;
  List<RatingsModel> get ratings;
  String get metascore;
  String get imdbRating;
  String get imdbVotes;
  String get imdbID;
  String get type;
  String get totalSeasons;
  String get response;
  String get videoID;

  Map<String, dynamic> toJson();
  $MovieModelCopyWith<MovieModel> get copyWith;
}

/// @nodoc
abstract class $MovieModelCopyWith<$Res> {
  factory $MovieModelCopyWith(
          MovieModel value, $Res Function(MovieModel) then) =
      _$MovieModelCopyWithImpl<$Res>;
  $Res call(
      {String title,
      String year,
      String rated,
      String released,
      String runtime,
      String genre,
      String director,
      String writer,
      String actors,
      String plot,
      String language,
      String country,
      String awards,
      String poster,
      List<RatingsModel> ratings,
      String metascore,
      String imdbRating,
      String imdbVotes,
      String imdbID,
      String type,
      String totalSeasons,
      String response,
      String videoID});
}

/// @nodoc
class _$MovieModelCopyWithImpl<$Res> implements $MovieModelCopyWith<$Res> {
  _$MovieModelCopyWithImpl(this._value, this._then);

  final MovieModel _value;
  // ignore: unused_field
  final $Res Function(MovieModel) _then;

  @override
  $Res call({
    Object title = freezed,
    Object year = freezed,
    Object rated = freezed,
    Object released = freezed,
    Object runtime = freezed,
    Object genre = freezed,
    Object director = freezed,
    Object writer = freezed,
    Object actors = freezed,
    Object plot = freezed,
    Object language = freezed,
    Object country = freezed,
    Object awards = freezed,
    Object poster = freezed,
    Object ratings = freezed,
    Object metascore = freezed,
    Object imdbRating = freezed,
    Object imdbVotes = freezed,
    Object imdbID = freezed,
    Object type = freezed,
    Object totalSeasons = freezed,
    Object response = freezed,
    Object videoID = freezed,
  }) {
    return _then(_value.copyWith(
      title: title == freezed ? _value.title : title as String,
      year: year == freezed ? _value.year : year as String,
      rated: rated == freezed ? _value.rated : rated as String,
      released: released == freezed ? _value.released : released as String,
      runtime: runtime == freezed ? _value.runtime : runtime as String,
      genre: genre == freezed ? _value.genre : genre as String,
      director: director == freezed ? _value.director : director as String,
      writer: writer == freezed ? _value.writer : writer as String,
      actors: actors == freezed ? _value.actors : actors as String,
      plot: plot == freezed ? _value.plot : plot as String,
      language: language == freezed ? _value.language : language as String,
      country: country == freezed ? _value.country : country as String,
      awards: awards == freezed ? _value.awards : awards as String,
      poster: poster == freezed ? _value.poster : poster as String,
      ratings:
          ratings == freezed ? _value.ratings : ratings as List<RatingsModel>,
      metascore: metascore == freezed ? _value.metascore : metascore as String,
      imdbRating:
          imdbRating == freezed ? _value.imdbRating : imdbRating as String,
      imdbVotes: imdbVotes == freezed ? _value.imdbVotes : imdbVotes as String,
      imdbID: imdbID == freezed ? _value.imdbID : imdbID as String,
      type: type == freezed ? _value.type : type as String,
      totalSeasons: totalSeasons == freezed
          ? _value.totalSeasons
          : totalSeasons as String,
      response: response == freezed ? _value.response : response as String,
      videoID: videoID == freezed ? _value.videoID : videoID as String,
    ));
  }
}

/// @nodoc
abstract class _$MovieModelCopyWith<$Res> implements $MovieModelCopyWith<$Res> {
  factory _$MovieModelCopyWith(
          _MovieModel value, $Res Function(_MovieModel) then) =
      __$MovieModelCopyWithImpl<$Res>;
  @override
  $Res call(
      {String title,
      String year,
      String rated,
      String released,
      String runtime,
      String genre,
      String director,
      String writer,
      String actors,
      String plot,
      String language,
      String country,
      String awards,
      String poster,
      List<RatingsModel> ratings,
      String metascore,
      String imdbRating,
      String imdbVotes,
      String imdbID,
      String type,
      String totalSeasons,
      String response,
      String videoID});
}

/// @nodoc
class __$MovieModelCopyWithImpl<$Res> extends _$MovieModelCopyWithImpl<$Res>
    implements _$MovieModelCopyWith<$Res> {
  __$MovieModelCopyWithImpl(
      _MovieModel _value, $Res Function(_MovieModel) _then)
      : super(_value, (v) => _then(v as _MovieModel));

  @override
  _MovieModel get _value => super._value as _MovieModel;

  @override
  $Res call({
    Object title = freezed,
    Object year = freezed,
    Object rated = freezed,
    Object released = freezed,
    Object runtime = freezed,
    Object genre = freezed,
    Object director = freezed,
    Object writer = freezed,
    Object actors = freezed,
    Object plot = freezed,
    Object language = freezed,
    Object country = freezed,
    Object awards = freezed,
    Object poster = freezed,
    Object ratings = freezed,
    Object metascore = freezed,
    Object imdbRating = freezed,
    Object imdbVotes = freezed,
    Object imdbID = freezed,
    Object type = freezed,
    Object totalSeasons = freezed,
    Object response = freezed,
    Object videoID = freezed,
  }) {
    return _then(_MovieModel(
      title: title == freezed ? _value.title : title as String,
      year: year == freezed ? _value.year : year as String,
      rated: rated == freezed ? _value.rated : rated as String,
      released: released == freezed ? _value.released : released as String,
      runtime: runtime == freezed ? _value.runtime : runtime as String,
      genre: genre == freezed ? _value.genre : genre as String,
      director: director == freezed ? _value.director : director as String,
      writer: writer == freezed ? _value.writer : writer as String,
      actors: actors == freezed ? _value.actors : actors as String,
      plot: plot == freezed ? _value.plot : plot as String,
      language: language == freezed ? _value.language : language as String,
      country: country == freezed ? _value.country : country as String,
      awards: awards == freezed ? _value.awards : awards as String,
      poster: poster == freezed ? _value.poster : poster as String,
      ratings:
          ratings == freezed ? _value.ratings : ratings as List<RatingsModel>,
      metascore: metascore == freezed ? _value.metascore : metascore as String,
      imdbRating:
          imdbRating == freezed ? _value.imdbRating : imdbRating as String,
      imdbVotes: imdbVotes == freezed ? _value.imdbVotes : imdbVotes as String,
      imdbID: imdbID == freezed ? _value.imdbID : imdbID as String,
      type: type == freezed ? _value.type : type as String,
      totalSeasons: totalSeasons == freezed
          ? _value.totalSeasons
          : totalSeasons as String,
      response: response == freezed ? _value.response : response as String,
      videoID: videoID == freezed ? _value.videoID : videoID as String,
    ));
  }
}

@JsonSerializable()

/// @nodoc
class _$_MovieModel implements _MovieModel {
  const _$_MovieModel(
      {this.title,
      this.year,
      this.rated,
      this.released,
      this.runtime,
      this.genre,
      this.director,
      this.writer,
      this.actors,
      this.plot,
      this.language,
      this.country,
      this.awards,
      this.poster,
      this.ratings,
      this.metascore,
      this.imdbRating,
      this.imdbVotes,
      this.imdbID,
      this.type,
      this.totalSeasons,
      this.response,
      this.videoID});

  factory _$_MovieModel.fromJson(Map<String, dynamic> json) =>
      _$_$_MovieModelFromJson(json);

  @override
  final String title;
  @override
  final String year;
  @override
  final String rated;
  @override
  final String released;
  @override
  final String runtime;
  @override
  final String genre;
  @override
  final String director;
  @override
  final String writer;
  @override
  final String actors;
  @override
  final String plot;
  @override
  final String language;
  @override
  final String country;
  @override
  final String awards;
  @override
  final String poster;
  @override
  final List<RatingsModel> ratings;
  @override
  final String metascore;
  @override
  final String imdbRating;
  @override
  final String imdbVotes;
  @override
  final String imdbID;
  @override
  final String type;
  @override
  final String totalSeasons;
  @override
  final String response;
  @override
  final String videoID;

  @override
  String toString() {
    return 'MovieModel(title: $title, year: $year, rated: $rated, released: $released, runtime: $runtime, genre: $genre, director: $director, writer: $writer, actors: $actors, plot: $plot, language: $language, country: $country, awards: $awards, poster: $poster, ratings: $ratings, metascore: $metascore, imdbRating: $imdbRating, imdbVotes: $imdbVotes, imdbID: $imdbID, type: $type, totalSeasons: $totalSeasons, response: $response, videoID: $videoID)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MovieModel &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.year, year) ||
                const DeepCollectionEquality().equals(other.year, year)) &&
            (identical(other.rated, rated) ||
                const DeepCollectionEquality().equals(other.rated, rated)) &&
            (identical(other.released, released) ||
                const DeepCollectionEquality()
                    .equals(other.released, released)) &&
            (identical(other.runtime, runtime) ||
                const DeepCollectionEquality()
                    .equals(other.runtime, runtime)) &&
            (identical(other.genre, genre) ||
                const DeepCollectionEquality().equals(other.genre, genre)) &&
            (identical(other.director, director) ||
                const DeepCollectionEquality()
                    .equals(other.director, director)) &&
            (identical(other.writer, writer) ||
                const DeepCollectionEquality().equals(other.writer, writer)) &&
            (identical(other.actors, actors) ||
                const DeepCollectionEquality().equals(other.actors, actors)) &&
            (identical(other.plot, plot) ||
                const DeepCollectionEquality().equals(other.plot, plot)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality()
                    .equals(other.country, country)) &&
            (identical(other.awards, awards) ||
                const DeepCollectionEquality().equals(other.awards, awards)) &&
            (identical(other.poster, poster) ||
                const DeepCollectionEquality().equals(other.poster, poster)) &&
            (identical(other.ratings, ratings) ||
                const DeepCollectionEquality()
                    .equals(other.ratings, ratings)) &&
            (identical(other.metascore, metascore) ||
                const DeepCollectionEquality()
                    .equals(other.metascore, metascore)) &&
            (identical(other.imdbRating, imdbRating) ||
                const DeepCollectionEquality()
                    .equals(other.imdbRating, imdbRating)) &&
            (identical(other.imdbVotes, imdbVotes) ||
                const DeepCollectionEquality()
                    .equals(other.imdbVotes, imdbVotes)) &&
            (identical(other.imdbID, imdbID) ||
                const DeepCollectionEquality().equals(other.imdbID, imdbID)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.totalSeasons, totalSeasons) ||
                const DeepCollectionEquality()
                    .equals(other.totalSeasons, totalSeasons)) &&
            (identical(other.response, response) ||
                const DeepCollectionEquality()
                    .equals(other.response, response)) &&
            (identical(other.videoID, videoID) ||
                const DeepCollectionEquality().equals(other.videoID, videoID)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(year) ^
      const DeepCollectionEquality().hash(rated) ^
      const DeepCollectionEquality().hash(released) ^
      const DeepCollectionEquality().hash(runtime) ^
      const DeepCollectionEquality().hash(genre) ^
      const DeepCollectionEquality().hash(director) ^
      const DeepCollectionEquality().hash(writer) ^
      const DeepCollectionEquality().hash(actors) ^
      const DeepCollectionEquality().hash(plot) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(awards) ^
      const DeepCollectionEquality().hash(poster) ^
      const DeepCollectionEquality().hash(ratings) ^
      const DeepCollectionEquality().hash(metascore) ^
      const DeepCollectionEquality().hash(imdbRating) ^
      const DeepCollectionEquality().hash(imdbVotes) ^
      const DeepCollectionEquality().hash(imdbID) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(totalSeasons) ^
      const DeepCollectionEquality().hash(response) ^
      const DeepCollectionEquality().hash(videoID);

  @override
  _$MovieModelCopyWith<_MovieModel> get copyWith =>
      __$MovieModelCopyWithImpl<_MovieModel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MovieModelToJson(this);
  }
}

abstract class _MovieModel implements MovieModel {
  const factory _MovieModel(
      {String title,
      String year,
      String rated,
      String released,
      String runtime,
      String genre,
      String director,
      String writer,
      String actors,
      String plot,
      String language,
      String country,
      String awards,
      String poster,
      List<RatingsModel> ratings,
      String metascore,
      String imdbRating,
      String imdbVotes,
      String imdbID,
      String type,
      String totalSeasons,
      String response,
      String videoID}) = _$_MovieModel;

  factory _MovieModel.fromJson(Map<String, dynamic> json) =
      _$_MovieModel.fromJson;

  @override
  String get title;
  @override
  String get year;
  @override
  String get rated;
  @override
  String get released;
  @override
  String get runtime;
  @override
  String get genre;
  @override
  String get director;
  @override
  String get writer;
  @override
  String get actors;
  @override
  String get plot;
  @override
  String get language;
  @override
  String get country;
  @override
  String get awards;
  @override
  String get poster;
  @override
  List<RatingsModel> get ratings;
  @override
  String get metascore;
  @override
  String get imdbRating;
  @override
  String get imdbVotes;
  @override
  String get imdbID;
  @override
  String get type;
  @override
  String get totalSeasons;
  @override
  String get response;
  @override
  String get videoID;
  @override
  _$MovieModelCopyWith<_MovieModel> get copyWith;
}

RatingsModel _$RatingsModelFromJson(Map<String, dynamic> json) {
  return _RatingsModel.fromJson(json);
}

/// @nodoc
class _$RatingsModelTearOff {
  const _$RatingsModelTearOff();

// ignore: unused_element
  _RatingsModel call({String source, String value}) {
    return _RatingsModel(
      source: source,
      value: value,
    );
  }

// ignore: unused_element
  RatingsModel fromJson(Map<String, Object> json) {
    return RatingsModel.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $RatingsModel = _$RatingsModelTearOff();

/// @nodoc
mixin _$RatingsModel {
  String get source;
  String get value;

  Map<String, dynamic> toJson();
  $RatingsModelCopyWith<RatingsModel> get copyWith;
}

/// @nodoc
abstract class $RatingsModelCopyWith<$Res> {
  factory $RatingsModelCopyWith(
          RatingsModel value, $Res Function(RatingsModel) then) =
      _$RatingsModelCopyWithImpl<$Res>;
  $Res call({String source, String value});
}

/// @nodoc
class _$RatingsModelCopyWithImpl<$Res> implements $RatingsModelCopyWith<$Res> {
  _$RatingsModelCopyWithImpl(this._value, this._then);

  final RatingsModel _value;
  // ignore: unused_field
  final $Res Function(RatingsModel) _then;

  @override
  $Res call({
    Object source = freezed,
    Object value = freezed,
  }) {
    return _then(_value.copyWith(
      source: source == freezed ? _value.source : source as String,
      value: value == freezed ? _value.value : value as String,
    ));
  }
}

/// @nodoc
abstract class _$RatingsModelCopyWith<$Res>
    implements $RatingsModelCopyWith<$Res> {
  factory _$RatingsModelCopyWith(
          _RatingsModel value, $Res Function(_RatingsModel) then) =
      __$RatingsModelCopyWithImpl<$Res>;
  @override
  $Res call({String source, String value});
}

/// @nodoc
class __$RatingsModelCopyWithImpl<$Res> extends _$RatingsModelCopyWithImpl<$Res>
    implements _$RatingsModelCopyWith<$Res> {
  __$RatingsModelCopyWithImpl(
      _RatingsModel _value, $Res Function(_RatingsModel) _then)
      : super(_value, (v) => _then(v as _RatingsModel));

  @override
  _RatingsModel get _value => super._value as _RatingsModel;

  @override
  $Res call({
    Object source = freezed,
    Object value = freezed,
  }) {
    return _then(_RatingsModel(
      source: source == freezed ? _value.source : source as String,
      value: value == freezed ? _value.value : value as String,
    ));
  }
}

@JsonSerializable()

/// @nodoc
class _$_RatingsModel implements _RatingsModel {
  const _$_RatingsModel({this.source, this.value});

  factory _$_RatingsModel.fromJson(Map<String, dynamic> json) =>
      _$_$_RatingsModelFromJson(json);

  @override
  final String source;
  @override
  final String value;

  @override
  String toString() {
    return 'RatingsModel(source: $source, value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _RatingsModel &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(source) ^
      const DeepCollectionEquality().hash(value);

  @override
  _$RatingsModelCopyWith<_RatingsModel> get copyWith =>
      __$RatingsModelCopyWithImpl<_RatingsModel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_RatingsModelToJson(this);
  }
}

abstract class _RatingsModel implements RatingsModel {
  const factory _RatingsModel({String source, String value}) = _$_RatingsModel;

  factory _RatingsModel.fromJson(Map<String, dynamic> json) =
      _$_RatingsModel.fromJson;

  @override
  String get source;
  @override
  String get value;
  @override
  _$RatingsModelCopyWith<_RatingsModel> get copyWith;
}
